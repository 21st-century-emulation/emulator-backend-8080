using System;

namespace emulator_backend_8080.Models
{
    internal enum Opcode
    {
        ACI,
        ADC,
        ADD,
        ADI,
        ANA,
        ANI,
        CALL,
        CC,
        CNC,
        CZ,
        CNZ,
        CPO,
        CPE,
        CP,
        CM,
        CMA,
        CMC,
        CMP,
        CPI,
        DAA,
        DAD,
        DCR,
        DCX,
        DI,
        EI,
        HLT,
        IN,
        INR,
        INX,
        JMP,
        JNZ,
        JZ,
        JNC,
        JC,
        JPO,
        JPE,
        JP,
        JM,
        LDA,
        LDAX,
        LHLD,
        LXI,
        MOV,
        MVI,
        NOOP,
        ORA,
        ORI,
        OUT,
        PCHL,
        POP,
        PUSH,
        RAL,
        RAR,
        RET,
        RNZ,
        RZ,
        RNC,
        RC,
        RPO,
        RPE,
        RP,
        RM,
        RLC,
        RRC,
        RST,
        SBB,
        SBI,
        SHLD,
        SPHL,
        STA,
        STAX,
        STC,
        SUB,
        SUI,
        XCHG,
        XRA,
        XRI,
        XTHL,
    }

    internal static class OpcodeExtensions
    {
        private static string RegisterFromArithmeticOp(byte opcode) => (opcode & 0xF) switch
        {
            0x0 => "B",
            0x8 => "B",
            0x1 => "C",
            0x9 => "C",
            0x2 => "D",
            0xA => "D",
            0x3 => "E",
            0xB => "E",
            0x4 => "H",
            0xC => "H",
            0x5 => "L",
            0xD => "L",
            0x6 => "(HL)",
            0xE => "(HL)",
            0x7 => "A",
            0xF => "A",
            _ => throw new ArgumentOutOfRangeException(nameof(opcode))
        };

        private static string OperandsAsWord(byte operand1, byte operand2) => $"{(((ushort)operand2 << 8) | (ushort)operand1):X4}";

        private static string DecodeMovDestination(byte opcode) => (opcode & 0xF0, opcode & 0x0F) switch 
        {
            (0x40, var lsn) when lsn < 8 => "B",
            (0x40, var lsn) when lsn >= 8 => "C",
            (0x50, var lsn) when lsn < 8 => "D",
            (0x50, var lsn) when lsn >= 8 => "E",
            (0x60, var lsn) when lsn < 8 => "H",
            (0x60, var lsn) when lsn >= 8 => "L",
            (0x70, var lsn) when lsn < 8 => "(HL)",
            (0x70, var lsn) when lsn >= 8 => "A",
            _ => throw new ArgumentOutOfRangeException(nameof(opcode))
        };

        private static string DecodeMovSource(byte opcode) => (opcode & 0x0F) switch 
        {
            0x0 => "B",
            0x1 => "C",
            0x2 => "D",
            0x3 => "E",
            0x4 => "H",
            0x5 => "L",
            0x6 => "(HL)",
            0x7 => "A",
            0x8 => "B",
            0x9 => "C",
            0xA => "D",
            0xB => "E",
            0xC => "H",
            0xD => "L",
            0xE => "(HL)",
            0xF => "A",
            _ => throw new ArgumentOutOfRangeException(nameof(opcode))
        };

        internal static string ToDebugString(this Opcode opcode, byte opcodeByte, byte operand1, byte operand2) => opcode switch
        {
            Opcode.ACI => $"ACI  {operand1:X2}",
            Opcode.ADC => $"ADC  {RegisterFromArithmeticOp(opcodeByte)}",
            Opcode.ADD => $"ADC  {RegisterFromArithmeticOp(opcodeByte)}",
            Opcode.ADI => $"ADI  {operand1:X2}",
            Opcode.ANA => $"ANA  {RegisterFromArithmeticOp(opcodeByte)}",
            Opcode.ANI => $"ANI  {operand1:X2}",
            Opcode.CALL => $"CALL {OperandsAsWord(operand1, operand2)}",
            Opcode.CC => $"CC   {OperandsAsWord(operand1, operand2)}",
            Opcode.CNC => $"CNC  {OperandsAsWord(operand1, operand2)}",
            Opcode.CZ => $"CZ   {OperandsAsWord(operand1, operand2)}",
            Opcode.CNZ => $"CNZ  {OperandsAsWord(operand1, operand2)}",
            Opcode.CPO => $"CPO  {OperandsAsWord(operand1, operand2)}",
            Opcode.CPE => $"CPE  {OperandsAsWord(operand1, operand2)}",
            Opcode.CP => $"CP   {OperandsAsWord(operand1, operand2)}",
            Opcode.CM => $"CM   {OperandsAsWord(operand1, operand2)}",
            Opcode.CMA => "CMA",
            Opcode.CMC => "CMC",
            Opcode.CMP => $"CMP  {RegisterFromArithmeticOp(opcodeByte)}",
            Opcode.CPI => $"CPI  {operand1:X2}",
            Opcode.DAA => "DAA",
            Opcode.DAD => $"DAD  {opcodeByte switch { 0x09 => "BC", 0x19 => "DE", 0x29 => "HL", 0x39 => "SP", _ => throw new ArgumentOutOfRangeException(nameof(opcodeByte), opcodeByte, "opcode byte is invalid" ) }}",
            Opcode.DCR => $"DCR  {opcodeByte switch { 0x05 => "B", 0x0D => "C", 0x15 => "D", 0x1D => "E", 0x25 => "H", 0x2D => "L", 0x35 => "(HL)", 0x3D => "A", _ => throw new ArgumentOutOfRangeException(nameof(opcodeByte), opcodeByte, "opcode byte is invalid") }}",
            Opcode.DCX => $"DCX  {opcodeByte switch { 0x0B => "BC", 0x1B => "DE", 0x2B => "HL", 0x3B => "SP", _ => throw new ArgumentOutOfRangeException(nameof(opcodeByte), opcodeByte, "opcode byte is invalid") }}",
            Opcode.DI => "DI",
            Opcode.EI => "EI",
            Opcode.HLT => "HLT",
            Opcode.IN => $"IN   {operand1:X2}",
            Opcode.INR => $"INR  {opcodeByte switch { 0x04 => "B", 0x0C => "C", 0x14 => "D", 0x1C => "E", 0x24 => "H", 0x2C => "L", 0x34 => "(HL)", 0x3C => "A", _ => throw new ArgumentOutOfRangeException(nameof(opcodeByte), opcodeByte, "opcode byte is invalid") }}",
            Opcode.INX => $"INX  {opcodeByte switch { 0x03 => "BC", 0x13 => "DE", 0x23 => "HL", 0x33 => "SP", _ => throw new ArgumentOutOfRangeException(nameof(opcodeByte), opcodeByte, "opcode byte is invalid") }}",
            Opcode.JMP => $"JMP  {OperandsAsWord(operand1, operand2)}",
            Opcode.JNZ => $"JNZ  {OperandsAsWord(operand1, operand2)}",
            Opcode.JZ => $"JZ   {OperandsAsWord(operand1, operand2)}",
            Opcode.JNC => $"JNC  {OperandsAsWord(operand1, operand2)}",
            Opcode.JC => $"JC   {OperandsAsWord(operand1, operand2)}",
            Opcode.JPO => $"JPO  {OperandsAsWord(operand1, operand2)}",
            Opcode.JPE => $"JPE  {OperandsAsWord(operand1, operand2)}",
            Opcode.JP => $"JP   {OperandsAsWord(operand1, operand2)}",
            Opcode.JM => $"JM   {OperandsAsWord(operand1, operand2)}",
            Opcode.LDA => $"LDA  ({OperandsAsWord(operand1, operand2)})",
            Opcode.LDAX => $"LDAX {opcodeByte switch { 0x0A => "BC", 0x1A => "DE", _ => throw new ArgumentOutOfRangeException(nameof(opcodeByte), opcodeByte, "opcode byte is invalid") }}",
            Opcode.LHLD => $"LHLD ({OperandsAsWord(operand1, operand2)}",
            Opcode.LXI => $"LXI  {opcodeByte switch { 0x01 => "BC", 0x11 => "DE", 0x21 => "HL", 0x31 => "SP", _ => throw new ArgumentOutOfRangeException(nameof(opcodeByte), opcodeByte, "opcode byte is invalid")}}, {OperandsAsWord(operand1, operand2)}",
            Opcode.MOV => $"MOV  {DecodeMovDestination(opcodeByte)},{DecodeMovSource(opcodeByte)}",
            Opcode.MVI => $"MVI  {opcodeByte switch { 0x06 => "B", 0x0E => "C", 0x16 => "D", 0x1E => "E", 0x26 => "H", 0x2E => "L", 0x36 => "(HL)", 0x3E => "A", _ => throw new ArgumentOutOfRangeException(nameof(opcodeByte), opcodeByte, "opcode byte is invalid") }}, {operand1:X2}",
            Opcode.NOOP => "NOOP",
            Opcode.ORA => $"ORA  {RegisterFromArithmeticOp(opcodeByte)}",
            Opcode.ORI => $"ORI  {operand1:X2}",
            Opcode.OUT => $"OUT  {operand1:X2}",
            Opcode.PCHL => "PCHL",
            Opcode.POP =>  $"POP  {opcodeByte switch { 0xC1 => "BC", 0xD1 => "DE", 0xE1 => "HL", 0xF1 => "PSW", _ => throw new ArgumentOutOfRangeException(nameof(opcodeByte), opcodeByte, "opcode byte is invalid") }}",
            Opcode.PUSH =>  $"PUSH {opcodeByte switch { 0xC5 => "BC", 0xD5 => "DE", 0xE5 => "HL", 0xF5 => "PSW", _ => throw new ArgumentOutOfRangeException(nameof(opcodeByte), opcodeByte, "opcode byte is invalid") }}",
            Opcode.RAL => "RAL",
            Opcode.RAR => "RAR",
            Opcode.RET => "RET",
            Opcode.RNZ => "RNZ",
            Opcode.RZ => "RZ",
            Opcode.RNC => "RNC",
            Opcode.RC => "RC",
            Opcode.RPO => "RPO",
            Opcode.RPE => "RPE",
            Opcode.RP => "RP",
            Opcode.RM => "RM",
            Opcode.RLC => "RLC",
            Opcode.RRC => "RRC",
            Opcode.RST => $"RST {opcodeByte switch { 0xC7 => "0", 0xCF => "1", 0xD7 => "2", 0xDF => "3", 0xE7 => "4", 0xEF => "5", 0xF7 => "6", 0xFF => "7", _ => throw new ArgumentOutOfRangeException(nameof(opcodeByte), opcodeByte, "opcode byte is invalid") }}",
            Opcode.SBB => $"SBB  {RegisterFromArithmeticOp(opcodeByte)}",
            Opcode.SBI => $"SBI  {operand1:X2}",
            Opcode.SHLD => $"SHLD ({OperandsAsWord(operand1, operand2)})",
            Opcode.SPHL => "SPHL",
            Opcode.STA => $"STA  ({OperandsAsWord(operand1, operand2)})",
            Opcode.STAX => $"STAX {opcodeByte switch { 0x02 => "BC", 0x12 => "DE", _ => throw new ArgumentOutOfRangeException(nameof(opcodeByte), opcodeByte, "opcode byte is invalid") }}",
            Opcode.STC => "STC",
            Opcode.SUB => $"SUB  {RegisterFromArithmeticOp(opcodeByte)}",
            Opcode.SUI => $"SUI  {operand1:X2}",
            Opcode.XCHG => "XCHG",
            Opcode.XRA => $"XRA  {RegisterFromArithmeticOp(opcodeByte)}",
            Opcode.XRI => $"XRI  {operand1:X2}",
            Opcode.XTHL => "XTHL",
            _ => throw new ArgumentOutOfRangeException(nameof(opcode))
        };
    }
}